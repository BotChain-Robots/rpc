// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_MPIMESSAGE_MESSAGING_H_
#define FLATBUFFERS_GENERATED_MPIMESSAGE_MESSAGING_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
// static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
//               FLATBUFFERS_VERSION_MINOR == 2 &&
//               FLATBUFFERS_VERSION_REVISION == 10,
//              "Non-compatible flatbuffers version included");

namespace Messaging {

struct MPIMessage;
struct MPIMessageBuilder;

enum MessageType : int8_t {
    MessageType_BROADCAST = 0,
    MessageType_PTP = 1,
    MessageType_MIN = MessageType_BROADCAST,
    MessageType_MAX = MessageType_PTP
};

inline const MessageType (&EnumValuesMessageType())[2] {
    static const MessageType values[] = {MessageType_BROADCAST, MessageType_PTP};
    return values;
}

inline const char *const *EnumNamesMessageType() {
    static const char *const names[3] = {"BROADCAST", "PTP", nullptr};
    return names;
}

inline const char *EnumNameMessageType(MessageType e) {
    if (::flatbuffers::IsOutRange(e, MessageType_BROADCAST, MessageType_PTP))
        return "";
    const size_t index = static_cast<size_t>(e);
    return EnumNamesMessageType()[index];
}

struct MPIMessage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
    typedef MPIMessageBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_TYPE = 4,
        VT_SENDER = 6,
        VT_DESTINATION = 8,
        VT_SEQUENCE_NUMBER = 10,
        VT_IS_DURABLE = 12,
        VT_LENGTH = 14,
        VT_TAG = 16,
        VT_PAYLOAD = 18
    };
    Messaging::MessageType type() const {
        return static_cast<Messaging::MessageType>(GetField<int8_t>(VT_TYPE, 0));
    }
    uint8_t sender() const {
        return GetField<uint8_t>(VT_SENDER, 0);
    }
    uint8_t destination() const {
        return GetField<uint8_t>(VT_DESTINATION, 0);
    }
    uint16_t sequence_number() const {
        return GetField<uint16_t>(VT_SEQUENCE_NUMBER, 0);
    }
    bool is_durable() const {
        return GetField<uint8_t>(VT_IS_DURABLE, 0) != 0;
    }
    uint16_t length() const {
        return GetField<uint16_t>(VT_LENGTH, 0);
    }
    uint8_t tag() const {
        return GetField<uint8_t>(VT_TAG, 0);
    }
    const ::flatbuffers::Vector<uint8_t> *payload() const {
        return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_PAYLOAD);
    }
    bool Verify(::flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) && VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
               VerifyField<uint8_t>(verifier, VT_SENDER, 1) &&
               VerifyField<uint8_t>(verifier, VT_DESTINATION, 1) &&
               VerifyField<uint16_t>(verifier, VT_SEQUENCE_NUMBER, 2) &&
               VerifyField<uint8_t>(verifier, VT_IS_DURABLE, 1) &&
               VerifyField<uint16_t>(verifier, VT_LENGTH, 2) &&
               VerifyField<uint8_t>(verifier, VT_TAG, 1) && VerifyOffset(verifier, VT_PAYLOAD) &&
               verifier.VerifyVector(payload()) && verifier.EndTable();
    }
};

struct MPIMessageBuilder {
    typedef MPIMessage Table;
    ::flatbuffers::FlatBufferBuilder &fbb_;
    ::flatbuffers::uoffset_t start_;
    void add_type(Messaging::MessageType type) {
        fbb_.AddElement<int8_t>(MPIMessage::VT_TYPE, static_cast<int8_t>(type), 0);
    }
    void add_sender(uint8_t sender) {
        fbb_.AddElement<uint8_t>(MPIMessage::VT_SENDER, sender, 0);
    }
    void add_destination(uint8_t destination) {
        fbb_.AddElement<uint8_t>(MPIMessage::VT_DESTINATION, destination, 0);
    }
    void add_sequence_number(uint16_t sequence_number) {
        fbb_.AddElement<uint16_t>(MPIMessage::VT_SEQUENCE_NUMBER, sequence_number, 0);
    }
    void add_is_durable(bool is_durable) {
        fbb_.AddElement<uint8_t>(MPIMessage::VT_IS_DURABLE, static_cast<uint8_t>(is_durable), 0);
    }
    void add_length(uint16_t length) {
        fbb_.AddElement<uint16_t>(MPIMessage::VT_LENGTH, length, 0);
    }
    void add_tag(uint8_t tag) {
        fbb_.AddElement<uint8_t>(MPIMessage::VT_TAG, tag, 0);
    }
    void add_payload(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> payload) {
        fbb_.AddOffset(MPIMessage::VT_PAYLOAD, payload);
    }
    explicit MPIMessageBuilder(::flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    ::flatbuffers::Offset<MPIMessage> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o = ::flatbuffers::Offset<MPIMessage>(end);
        return o;
    }
};

inline ::flatbuffers::Offset<MPIMessage>
CreateMPIMessage(::flatbuffers::FlatBufferBuilder &_fbb,
                 Messaging::MessageType type = Messaging::MessageType_BROADCAST, uint8_t sender = 0,
                 uint8_t destination = 0, uint16_t sequence_number = 0, bool is_durable = false,
                 uint16_t length = 0, uint8_t tag = 0,
                 ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> payload = 0) {
    MPIMessageBuilder builder_(_fbb);
    builder_.add_payload(payload);
    builder_.add_length(length);
    builder_.add_sequence_number(sequence_number);
    builder_.add_tag(tag);
    builder_.add_is_durable(is_durable);
    builder_.add_destination(destination);
    builder_.add_sender(sender);
    builder_.add_type(type);
    return builder_.Finish();
}

inline ::flatbuffers::Offset<MPIMessage>
CreateMPIMessageDirect(::flatbuffers::FlatBufferBuilder &_fbb,
                       Messaging::MessageType type = Messaging::MessageType_BROADCAST,
                       uint8_t sender = 0, uint8_t destination = 0, uint16_t sequence_number = 0,
                       bool is_durable = false, uint16_t length = 0, uint8_t tag = 0,
                       const std::vector<uint8_t> *payload = nullptr) {
    auto payload__ = payload ? _fbb.CreateVector<uint8_t>(*payload) : 0;
    return Messaging::CreateMPIMessage(_fbb, type, sender, destination, sequence_number, is_durable,
                                       length, tag, payload__);
}

inline const Messaging::MPIMessage *GetMPIMessage(const void *buf) {
    return ::flatbuffers::GetRoot<Messaging::MPIMessage>(buf);
}

inline const Messaging::MPIMessage *GetSizePrefixedMPIMessage(const void *buf) {
    return ::flatbuffers::GetSizePrefixedRoot<Messaging::MPIMessage>(buf);
}

inline bool VerifyMPIMessageBuffer(::flatbuffers::Verifier &verifier) {
    return verifier.VerifyBuffer<Messaging::MPIMessage>(nullptr);
}

inline bool VerifySizePrefixedMPIMessageBuffer(::flatbuffers::Verifier &verifier) {
    return verifier.VerifySizePrefixedBuffer<Messaging::MPIMessage>(nullptr);
}

inline void FinishMPIMessageBuffer(::flatbuffers::FlatBufferBuilder &fbb,
                                   ::flatbuffers::Offset<Messaging::MPIMessage> root) {
    fbb.Finish(root);
}

inline void FinishSizePrefixedMPIMessageBuffer(::flatbuffers::FlatBufferBuilder &fbb,
                                               ::flatbuffers::Offset<Messaging::MPIMessage> root) {
    fbb.FinishSizePrefixed(root);
}

} // namespace Messaging

#endif // FLATBUFFERS_GENERATED_MPIMESSAGE_MESSAGING_H_
